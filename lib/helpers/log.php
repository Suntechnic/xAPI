<?
// \X\Helpers\Log::add($msg, $file, $agent);

namespace X\Helpers
{
    class Log
    {
        
        const LOCKDIR = 'locks';
        
        /*
        Уровни логирования
        В не production окружении всегда не ниже 4
        В dev окружении всегда 5
        */
        const LEVELS = [
                'CRITICAL' => 0, // — событие, когда сбой даёт компонент системы, который очень важен и всегда должен работать. Подходит для событий, о которых важно оперативно узнать, даже если оно произошло всего раз.
                'ERROR' => 1, // — произошло событие о, котором при скором повторении нужно сообщить. Не удалось выполнить действие, которое обязательно должно быть выполнено, но при этом такое действие не попадает под описание critical. Например, не удалось сохранить аватарку пользователя по его запросу, но при этом система не является сервисом аватарок, а является чат-системой.
                'WARNING' => 2, // — события, для немедленного уведомления о которых нужно набрать значительное их количество за период времени. Не удалось выполнить действие, невыполнение которого ничего серьезного не ломает. Это всё ещё ошибки, но исправление которых может ждать рабочего расписания. Например, не удалось сохранить аватарку пользователя, а система — интернет-магазин. Уведомление о них нужно (при высокой частоте), чтобы узнать о внезапных аномалиях, потому что они могут быть симптомами более серьезных проблем.
                'NOTICE' => 3, // — это события, которые сообщают о предусмотренных системой отклонениях, которые являются частью нормального функционирования системы. Например, пользователь указал неправильный пароль при входе, пользователь не заполнил отчество, но оно и не обязательно, пользователь купил заказ за 0 рублей, но у вас такое предусмотрено в редких случаях. Уведомление по ним при высокой частоте тоже нужно, так как резкий рост числа отклонений может быть результатом допущенной ошибки, которую срочно нужно исправить.
                'INFO' => 4, // — события, возникновение которых сообщает о нормальном функционировании системы. Например, пользователь зарегистрировался, пользователь приобрел товар, пользователь оставил отзыв. Уведомление по таким событиями нужно настраивать в обратном виде: если за период времени произошло недостаточное количество таких событий, то нужно уведомить, потому что их снижение могло быть вызвано в результате допущенной ошибки.
                'DEBUG' => 5, // — события для отладки какого-либо процесса в системе. При добавлении достаточного количества данных в контекст события можно произвести диагностику проблемы, либо заключить об исправном функционировании процесса в системе. Например, пользователь открыл страницу с товаром и получил список рекомендаций. Значительно увеличивает количество отправляемых событий, поэтому допустимо убирать логирование таких событий через некоторое время. Как результат, количество таких событий в нормальном функционировании будет переменным, тогда и мониторинг для уведомления по ним можно не подключать.'EMERGENCY' => 0,
            ];
        private static $dctRevertLevels = false;
        
        public static function add($msg, $file, $agent='x') {
            if (is_array($msg)) $msg.= print_r($msg,true);
            self::push(5, $msg, $file, $agent);
        }
        
        
        public static function push($level, $msg, $file, $agent='x', $context=false) {
            if ($level > APPLICATION_LOGLEVEL) return; // уровень ниже уровня логирования
            if (!defined('S_P_LOG')) return; // лог вообще не определен
            
            if (!self::$dctRevertLevels) self::$dctRevertLevels = array_flip(self::LEVELS);
            $LVL = self::$dctRevertLevels[$level];
            
            $dir = S_P_LOG.'/'.$agent;
            if (!file_exists($dir)) mkdir($dir, 0755, true);
            $path = $dir.'/'.$file.'.txt';
            
            $msg = '['.date('d-m-Y H:i:s').']['.$LVL.'] '.$msg."\n";
            if ($context) {
                if (!is_array($context))  {
                    //TODO: автосоздание контекста
                    
                }
                $msg.= "CONTEXT:\n".print_r($context,true)."\n";
            }
            
            if ($stream = fopen($path, 'a')) {
                self::_write($stream, $msg);
                fclose($stream);
            }
        }
        
        private static function _write ($stream, $data) {  
            flock($stream, LOCK_EX);
            fwrite($stream, $data);
            fflush($stream);
            flock($stream, LOCK_UN);
        }
        
        /*
        ставим блокировку по ключу
        возвращет true если удалось получить блокировку
        */
        public static function lock($key) {  
            $lockFile = self::_getLockFile($key);
            
            if ($lockFile === false) {
                self::add('Попытка получить блокировку '.$key.' когда блокировки не работают', 'locks');
                return false; // неудалось получить блокировку
            }
            
            if (file_exists($lockFile)) {
                self::add('Неудачная попытка захватить блокировку '.$key, 'locks');
                return false; // неудалось захватить блокировку
            }
            
            if ($stream = fopen($lockFile, 'w')) {
                self::_write($stream, time());
                fclose($stream);
                return true;
            }
            
            self::add('Неудалось предоставить блокировку '.$key, 'locks');
            return false;
        }
        
        /*
        снимает блокировку по ключу
        возвращет true если удалось получить блокировку
        */
        public static function unlock($key) {  
            $lockFile = self::_getLockFile($key);
            if (file_exists($lockFile)) {
                unlink($lockFile);
                return true;
            } else return false;
        }
        
        /*
        проверяет блокировку
        возвращет true если удалось получить блокировку
        */
        public static function islocked($key) {  
            $lockFile = self::_getLockFile($key);
            return file_exists($lockFile);
        }
        
        private static function _getLockFile ($key) {  
            if (!defined('S_P_LOG')) return false;
            $dir = S_P_LOG.'/'.self::LOCKDIR;
            if (!file_exists($dir)) mkdir($dir);
            if (is_dir($dir)) {
                $lockFile = $dir.'/'.$key;
                return $lockFile;
            }
            return false;
        }
        
        
    }
}

